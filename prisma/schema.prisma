generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

// Enums
enum Role {
  USER
  CREATOR
  ADMIN
}

enum CallOfferStatus {
  AVAILABLE
  BOOKED
  COMPLETED
  CANCELLED
}

enum BookingStatus {
  PENDING
  CONFIRMED
  COMPLETED
  CANCELLED
}

enum PaymentStatus {
  PENDING
  SUCCEEDED
  FAILED
}

enum CallRequestStatus {
  PENDING
  ACCEPTED
  REJECTED
}

enum PayoutStatus {
  REQUESTED // Demande créée par le créateur
  APPROVED // Approuvée par l'admin
  PROCESSING // Payout Stripe en cours
  PAID // Payout réussi
  FAILED // Payout échoué
  REJECTED // Refusée par l'admin
  CANCELED // Annulée
}

enum NotificationType {
  BOOKING_CONFIRMED
  BOOKING_CANCELLED
  CALL_REQUEST
  REVIEW_RECEIVED
  PAYOUT_COMPLETED
  SYSTEM
  PAYMENT_RECEIVED
  PAYOUT_REQUEST
  PAYOUT_APPROVED
  PAYOUT_FAILED
  REFUND_CREATED
  DISPUTE_CREATED
  DEBT_DEDUCTED
  TRANSFER_FAILED
  DEBT_THRESHOLD_EXCEEDED
}

// User's payout schedule enums
enum PayoutSchedule {
  DAILY
  WEEKLY
  MANUAL
}

enum PayoutAction {
  TRIGGERED
  BLOCKED
  UNBLOCKED
  COMPLETED
  FAILED
}

// Payment system enums
enum PayoutMode {
  AUTOMATIC
  MANUAL
}

enum PayoutFrequency {
  DAILY
  WEEKLY
  MONTHLY
}

enum TransactionEventType {
  PAYMENT_CREATED
  PAYMENT_SUCCEEDED
  PAYMENT_FAILED
  REFUND_CREATED
  REFUND_SUCCEEDED
  REFUND_FAILED
  PAYOUT_CREATED
  PAYOUT_PAID
  PAYOUT_FAILED
  TRANSFER_CREATED
  TRANSFER_SUCCEEDED
  TRANSFER_FAILED
  WEBHOOK_RECEIVED
  DISPUTE_CREATED
  DISPUTE_UPDATED
  DISPUTE_CLOSED
}

// System-wide logging enums
enum LogLevel {
  INFO
  WARNING
  ERROR
  CRITICAL
}

enum LogActor {
  USER
  CREATOR
  ADMIN
  SYSTEM
  GUEST
}

// ✅ NEW: Logging system for emails and crons
enum LogType {
  EMAIL_SENT
  EMAIL_ERROR
  CRON_RUN
  CRON_ERROR
  DAILY_ROOM_DELETED
  DAILY_ROOM_ERROR
  BOOKING_CREATED
  BOOKING_ERROR
  PAYMENT_SUCCESS
  PAYMENT_ERROR
  PAYMENT_REFUND
  PAYOUT_SUCCESS
  PAYOUT_ERROR
  STRIPE_WEBHOOK
  STRIPE_WEBHOOK_ERROR
  DAILY_ROOM_CREATED
  NOTIFICATION_SENT
  NOTIFICATION_ERROR
  SYSTEM_ERROR
  API_ERROR
  CALL_EVENT
}

enum LogStatus {
  SUCCESS
  ERROR
}

enum EntityType {
  PAYMENT
  PAYOUT
  REFUND
  DISPUTE
  TRANSFER
}

enum RefundStatus {
  PENDING
  SUCCEEDED
  FAILED
  CANCELLED
}

enum DisputeStatus {
  WARNING_NEEDS_RESPONSE
  WARNING_UNDER_REVIEW
  WARNING_CLOSED
  NEEDS_RESPONSE
  UNDER_REVIEW
  CHARGE_REFUNDED
  WON
  LOST
}

// Models
model User {
  id            String    @id @default(cuid())
  email         String    @unique
  password      String?
  name          String
  emailVerified DateTime?
  image         String?
  role          Role      @default(USER)
  timezone      String    @default("Europe/Paris") // User's timezone (IANA format)
  createdAt     DateTime  @default(now())
  updatedAt     DateTime  @updatedAt

  // Relations
  creator         Creator?
  bookings        Booking[]
  callRequests    CallRequest[]
  reviews         Review[]
  notifications   Notification[]
  accounts        Account[]
  sessions        Session[]
  payoutsApproved Payout[]       @relation("PayoutApprovedBy")

  @@index([email])
}

model Account {
  id                String  @id @default(cuid())
  userId            String
  type              String
  provider          String
  providerAccountId String
  refresh_token     String? @db.Text
  access_token      String? @db.Text
  expires_at        Int?
  token_type        String?
  scope             String?
  id_token          String? @db.Text
  session_state     String?

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([provider, providerAccountId])
  @@index([userId])
}

model Session {
  id           String   @id @default(cuid())
  sessionToken String   @unique
  userId       String
  expires      DateTime
  user         User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
}

model VerificationToken {
  identifier String
  token      String   @unique
  expires    DateTime

  @@unique([identifier, token])
}

model Creator {
  id                String  @id @default(cuid())
  userId            String  @unique
  bio               String? @db.Text
  expertise         String?
  profileImage      String?
  bannerImage       String?
  stripeAccountId   String?
  isStripeOnboarded Boolean @default(false)

  // ✅ NEW: Creator's currency (automatically detected from Stripe Connect account)
  currency String @default("EUR") // EUR, CHF, USD, GBP, etc.
  
  // ✅ NEW: Creator's timezone (IANA format, e.g., "Europe/Paris", "America/New_York")
  timezone String @default("Europe/Paris")
  
  // ✅ NEW: Social media links (stored as JSON)
  socialLinks Json? // { instagram, tiktok, twitter, youtube, other }

  // User's payout settings (from feature branch)
  payoutSchedule    PayoutSchedule @default(WEEKLY)
  payoutMinimum     Decimal        @default(10) @db.Decimal(10, 2)
  isPayoutBlocked   Boolean        @default(false)
  payoutBlockReason String?

  // Payment system fields
  payoutBlocked       Boolean @default(false)
  payoutBlockedReason String? @db.Text

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relations
  user                 User               @relation(fields: [userId], references: [id], onDelete: Cascade)
  callOffers           CallOffer[]
  callRequestsReceived CallRequest[]      @relation("CreatorRequests")
  reviewsReceived      Review[]           @relation("CreatorReviews")
  payouts              Payout[]
  payoutAuditLogs      PayoutAuditLog[]
  payoutScheduleNew    PayoutScheduleNew?
  refundsInitiated     Refund[]           @relation("RefundInitiator")

  @@index([userId])
  @@index([isPayoutBlocked])
  @@index([currency])
}

model CallOffer {
  id          String  @id @default(cuid())
  creatorId   String
  title       String
  description String  @db.Text
  price       Decimal @db.Decimal(10, 2)

  // ✅ NEW: Offer currency (same as creator's currency)
  currency String @default("EUR") // EUR, CHF, USD, GBP, etc.

  dateTime        DateTime
  duration        Int // in minutes
  status          CallOfferStatus @default(AVAILABLE)
  maxParticipants Int             @default(1)
  createdAt       DateTime        @default(now())
  updatedAt       DateTime        @updatedAt

  // Relations
  creator Creator  @relation(fields: [creatorId], references: [id], onDelete: Cascade)
  booking Booking?

  @@index([creatorId])
  @@index([status])
  @@index([dateTime])
  @@index([currency])
}

model Booking {
  id                    String        @id @default(cuid())
  userId                String
  callOfferId           String        @unique
  status                BookingStatus @default(PENDING)
  totalPrice            Decimal       @db.Decimal(10, 2)
  stripePaymentIntentId String?
  dailyRoomUrl          String?
  dailyRoomName         String?
  isTestBooking         Boolean       @default(false) // Flag for test/development bookings
  reminderSent          Boolean       @default(false) // Flag to track if reminder email was sent
  createdAt             DateTime      @default(now())
  updatedAt             DateTime      @updatedAt

  // Relations
  user      User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  callOffer CallOffer @relation(fields: [callOfferId], references: [id], onDelete: Cascade)
  payment   Payment?
  review    Review?

  @@index([userId])
  @@index([status])
  @@index([isTestBooking])
  @@index([reminderSent])
}

model Payment {
  id        String  @id @default(cuid())
  bookingId String  @unique
  amount    Decimal @db.Decimal(10, 2)

  // ✅ NEW: Payment currency (same as creator's currency)
  currency String @default("EUR") // EUR, CHF, USD, GBP, etc.

  stripePaymentIntentId String
  status                PaymentStatus @default(PENDING)
  platformFee           Decimal       @db.Decimal(10, 2)
  creatorAmount         Decimal       @db.Decimal(10, 2)
  refundedAmount        Decimal       @default(0) @db.Decimal(10, 2)
  disputeStatus         String?
  createdAt             DateTime      @default(now())

  // Payout tracking fields
  payoutStatus      PayoutStatus @default(REQUESTED)
  payoutReleaseDate DateTime? // Date when funds can be transferred (payment date + 7 days)
  stripeTransferId  String? // Stripe transfer ID when payout is completed
  payoutDate        DateTime? // Date when payout was actually transferred

  // ✅ NEW: Separate Charges and Transfers fields
  transferId     String? // Stripe Transfer ID (from stripe.transfers.create)
  transferStatus String? // Transfer status: "PENDING", "SUCCEEDED", "FAILED"

  // Relations
  booking         Booking          @relation(fields: [bookingId], references: [id], onDelete: Cascade)
  refunds         Refund[]
  disputes        Dispute[]
  transactionLogs TransactionLog[] @relation("PaymentLogs")

  @@index([stripePaymentIntentId])
  @@index([payoutStatus])
  @@index([currency])
  @@index([transferId])
}

model CallRequest {
  id               String            @id @default(cuid())
  userId           String
  creatorId        String
  proposedPrice    Decimal           @db.Decimal(10, 2)
  proposedDateTime DateTime
  message          String            @db.Text
  status           CallRequestStatus @default(PENDING)
  createdAt        DateTime          @default(now())
  updatedAt        DateTime          @updatedAt

  // Relations
  user    User    @relation(fields: [userId], references: [id], onDelete: Cascade)
  creator Creator @relation("CreatorRequests", fields: [creatorId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([creatorId])
  @@index([status])
}

model Review {
  id        String   @id @default(cuid())
  bookingId String   @unique
  userId    String
  creatorId String
  rating    Int // 1-5
  comment   String   @db.Text
  createdAt DateTime @default(now())

  // Relations
  booking Booking @relation(fields: [bookingId], references: [id], onDelete: Cascade)
  user    User    @relation(fields: [userId], references: [id], onDelete: Cascade)
  creator Creator @relation("CreatorReviews", fields: [creatorId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([creatorId])
  @@index([rating])
}

model Notification {
  id        String           @id @default(cuid())
  userId    String
  type      NotificationType
  title     String
  message   String           @db.Text
  link      String?
  read      Boolean          @default(false)
  metadata  Json? // Données additionnelles (paymentId, payoutId, amount, etc.)
  createdAt DateTime         @default(now())
  readAt    DateTime? // Date when notification was marked as read

  // Relations
  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([read])
  @@index([createdAt])
}

model Payout {
  id        String       @id @default(cuid())
  creatorId String
  amount    Decimal      @db.Decimal(10, 2)
  currency  String       @default("EUR")
  status    PayoutStatus @default(REQUESTED)

  // Stripe
  stripePayoutId String? @unique

  // Dates
  requestedAt DateTime  @default(now())
  approvedAt  DateTime?
  paidAt      DateTime?
  failedAt    DateTime?
  rejectedAt  DateTime?

  // Relations
  approvedById String?
  approvedBy   User?   @relation("PayoutApprovedBy", fields: [approvedById], references: [id])

  // Raisons
  rejectionReason String? @db.Text
  failureReason   String? @db.Text

  // Metadata
  metadata Json?

  // Audit
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relations
  creator         Creator          @relation(fields: [creatorId], references: [id], onDelete: Cascade)
  auditLogs       PayoutAuditLog[]
  transactionLogs TransactionLog[] @relation("PayoutLogs")

  @@index([creatorId])
  @@index([status])
  @@index([currency])
  @@index([stripePayoutId])
}

model AdminSettings {
  id        String   @id @default(cuid())
  key       String   @unique
  value     String
  updatedAt DateTime @updatedAt

  @@index([key])
}

// User's audit log model
model PayoutAuditLog {
  id             String        @id @default(cuid())
  creatorId      String
  payoutId       String? // Reference to the Payout entity
  action         PayoutAction
  amount         Decimal?      @db.Decimal(10, 2)
  status         PayoutStatus?
  stripePayoutId String?
  adminId        String?
  reason         String?       @db.Text
  metadata       String?       @db.Text // JSON string for additional data
  createdAt      DateTime      @default(now())
  updatedAt      DateTime      @updatedAt

  // Relations
  creator Creator @relation(fields: [creatorId], references: [id], onDelete: Cascade)
  payout  Payout? @relation(fields: [payoutId], references: [id], onDelete: Cascade)

  @@index([creatorId])
  @@index([payoutId])
  @@index([action])
  @@index([createdAt])
}

// Platform-wide financial settings (singleton pattern - should have only one row)
model PlatformSettings {
  id                     String     @id @default(cuid())
  platformFeePercentage  Decimal    @db.Decimal(5, 2) // e.g., 15.00 for 15%
  platformFeeFixed       Decimal?   @db.Decimal(10, 2) // Optional fixed fee in addition to percentage
  minimumPayoutAmount    Decimal    @db.Decimal(10, 2) // e.g., 10.00 EUR
  holdingPeriodDays      Int // e.g., 7 days
  payoutMode             PayoutMode @default(AUTOMATIC)
  payoutFrequencyOptions String[] // e.g., ["DAILY", "WEEKLY", "MONTHLY"]
  currency               String     @default("EUR")
  createdAt              DateTime   @default(now())
  updatedAt              DateTime   @updatedAt
}

// Comprehensive audit log for all financial transactions
model TransactionLog {
  id            String               @id @default(cuid())
  eventType     TransactionEventType
  entityType    EntityType
  entityId      String // ID of the related entity (payment, payout, refund, etc.)
  stripeEventId String? // Stripe event ID for webhook events
  amount        Decimal?             @db.Decimal(10, 2)
  currency      String?
  status        String?
  metadata      Json? // Additional structured data
  errorMessage  String?              @db.Text
  createdAt     DateTime             @default(now())

  // Optional relations
  paymentId String?
  payoutId  String?
  refundId  String?

  payment Payment? @relation("PaymentLogs", fields: [paymentId], references: [id], onDelete: SetNull)
  payout  Payout?  @relation("PayoutLogs", fields: [payoutId], references: [id], onDelete: SetNull)
  refund  Refund?  @relation("RefundLogs", fields: [refundId], references: [id], onDelete: SetNull)

  @@index([eventType])
  @@index([entityType])
  @@index([entityId])
  @@index([createdAt])
  @@index([stripeEventId])
}

// Refund tracking
model Refund {
  id             String       @id @default(cuid())
  paymentId      String
  amount         Decimal      @db.Decimal(10, 2)
  currency       String       @default("EUR")
  reason         String       @db.Text
  status         RefundStatus @default(PENDING)
  stripeRefundId String?      @unique
  initiatedById  String // Admin/Creator who initiated the refund

  // ✅ NEW: Separate Charges and Transfers - Creator debt tracking
  creatorDebt  Decimal   @default(0) @db.Decimal(10, 2) // Amount creator owes (85% of refund)
  reconciled   Boolean   @default(false) // Whether the debt has been recovered
  reconciledAt DateTime? // When the debt was reconciled
  reconciledBy String? // How it was reconciled: "TRANSFER_REVERSAL", "PAYOUT_DEDUCTION", "MANUAL"
  reversalId   String? // Stripe Transfer Reversal ID if applicable

  metadata  Json?
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relations
  payment         Payment          @relation(fields: [paymentId], references: [id], onDelete: Cascade)
  initiatedBy     Creator          @relation("RefundInitiator", fields: [initiatedById], references: [id])
  transactionLogs TransactionLog[] @relation("RefundLogs")

  @@index([paymentId])
  @@index([status])
  @@index([stripeRefundId])
  @@index([reconciled])
}

// Dispute/Chargeback tracking
model Dispute {
  id              String        @id @default(cuid())
  paymentId       String
  stripeDisputeId String        @unique
  amount          Decimal       @db.Decimal(10, 2)
  currency        String        @default("EUR")
  reason          String
  status          DisputeStatus
  evidenceDetails Json? // Store evidence submission details

  // ✅ NEW: Separate Charges and Transfers - Creator debt tracking
  creatorDebt  Decimal   @default(0) @db.Decimal(10, 2) // Amount creator owes (85% of dispute)
  reconciled   Boolean   @default(false) // Whether the debt has been recovered
  reconciledAt DateTime? // When the debt was reconciled
  reconciledBy String? // How it was reconciled: "TRANSFER_REVERSAL", "PAYOUT_DEDUCTION", "MANUAL"
  reversalId   String? // Stripe Transfer Reversal ID if applicable

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relations
  payment Payment @relation(fields: [paymentId], references: [id], onDelete: Cascade)

  @@index([paymentId])
  @@index([status])
  @@index([stripeDisputeId])
  @@index([reconciled])
}

// Per-creator payout scheduling (renamed to avoid conflict with enum)
model PayoutScheduleNew {
  id             String          @id @default(cuid())
  creatorId      String          @unique
  mode           PayoutMode      @default(AUTOMATIC)
  frequency      PayoutFrequency @default(WEEKLY)
  nextPayoutDate DateTime?
  isActive       Boolean         @default(true)
  createdAt      DateTime        @default(now())
  updatedAt      DateTime        @updatedAt

  // Relations
  creator Creator @relation(fields: [creatorId], references: [id], onDelete: Cascade)

  @@index([creatorId])
  @@index([nextPayoutDate])
  @@index([isActive])
}

// ✅ IMPROVED: System-wide activity logs for emails, crons, and system events
// This model provides complete audit trail for all emails and cron jobs
model Log {
  id        String    @id @default(cuid())
  type      LogType // Email, cron, booking, payment, etc.
  status    LogStatus // SUCCESS or ERROR
  message   String    @db.Text // Human-readable message for admin
  context   Json? // bookingId, userId, offerId, roomId, emailType, cronType, etc.
  error     String?   @db.Text // Stack trace or detailed error message (only if status = ERROR)
  createdAt DateTime  @default(now())

  // Performance indexes for frequent queries
  @@index([type])
  @@index([status])
  @@index([createdAt])
  @@index([type, status]) // Composite index for filtering by type and status
  @@index([type, createdAt]) // Composite index for type-based time queries
  @@index([status, createdAt]) // Composite index for error monitoring
}
